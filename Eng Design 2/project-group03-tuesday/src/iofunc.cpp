/*
Comp Eng 3DY4 (Computer Systems Integration Project)

Department of Electrical and Computer Engineering
McMaster University
Ontario, Canada
*/

#include "dy4.h"
#include "iofunc.h"

// some basic functions for printing information from vectors
// or to read from/write to binary files in 32-bit float format
void printRealVector(const std::vector<float> &x)
{
	std::cout << "Printing float vector of size " << x.size() << "\n";
	for (int i = 0; i < (int)x.size(); i++)
		std::cout << x[i] << " ";
	std::cout << "\n";
}

void printComplexVector(const std::vector<std::complex<float>> &X)
{
	std::cout << "Printing complex vector of size " << X.size() << "\n";
	for (int i = 0; i < (int)X.size(); i++)
		std::cout << X[i] << " ";
	std::cout << "\n";
}

// assumes data in the raw binary file is in 32-bit float format
void readBinData(const std::string in_fname, std::vector<float> &bin_data)
{
	std::cout << "Using file " << in_fname << " (for lab 3 generated by ../model/fmMonoBlock.py)\n";
	std::ifstream fdin(in_fname, std::ios::binary);
	if(!fdin) {
		std::cout << "File " << in_fname << " not found ... exiting!\n";
		exit(1);
	} else {
		std::cout << "Reading raw binary from \"" << in_fname << "\"\n";
	}
	fdin.seekg(0, std::ios::end);
	const unsigned int num_samples = fdin.tellg() / sizeof(float);

	bin_data.resize(num_samples);
	fdin.seekg(0, std::ios::beg);
	fdin.read(reinterpret_cast<char*>(&bin_data[0]), num_samples*sizeof(float));
	fdin.close();
}

// assumes data in the raw binary file is 32-bit float format
void writeBinData(const std::string out_fname, const std::vector<float> &bin_data)
{
	std::cout << "Writing raw binary to \"" << out_fname << "\"\n";
	std::ofstream fdout(out_fname, std::ios::binary);
	for (int i=0; i<(int)bin_data.size(); i++) {
		fdout.write(reinterpret_cast<const char*>(&bin_data[i]),\
								sizeof(bin_data[i]));
	}
	fdout.close();
}

// reads in data from stdin
void readStdinBlockData(unsigned int num_samples, unsigned int block_id, std::vector<float> &block_data){

	std::vector<char> raw_data(num_samples);
	std::cin.read(reinterpret_cast<char*>(&raw_data[0]), num_samples*sizeof(char));

	block_data.resize(num_samples); // Ensure block_data has enough space

	for (int k=0; k<(int)num_samples; k++) {
		// automatically normalizes the data to the range -1 to +1
		block_data[k] = float(((unsigned char)raw_data[k]-128)/128.0);
	}

}

void readFileData(std::vector<float> I, std::vector<float> Q){
	const std::string in_fname = "../data/iqsamples.raw";
	std::vector<float> audio_data;
	// read_audio_data(in_fname, audio_data);

	// read in data from in_fname as type uint8
	std::ifstream myfile;
	myfile.open(in_fname, std::ios::binary);

	

	if (myfile.is_open())
	{
		std::cout << "1" << std::endl; //////////////////////
		// get the number of samples in the file
		myfile.seekg(0, myfile.end);
		int file_length = myfile.tellg();
		myfile.seekg(0, myfile.beg);

		// read in the data
		std::vector<uint8_t> uint8_audio_data(file_length);
		myfile.read((char *)&uint8_audio_data[0], file_length);
		myfile.close();

		// convert the uint8 data to float
		audio_data.resize(file_length);
		for (int i = 0; i < file_length; i++)
		{
			/*if (i % 2){

			} else {*/
			audio_data[i] = (float)uint8_audio_data[i];
			//}
		}
		std::cout << "2" << std::endl; //////////////////////
		// normalize between -1 and 1
		for (int i = 0; i < file_length; i++)
		{
			audio_data[i] = (audio_data[i] - 128) / 128;
		}
		std::cout << "3" << std::endl; //////////////////////
		// split into i and q
		for (int i = 0; i < file_length; i++)
		{
			if (i % 2)
			{
				Q.push_back(audio_data[i]);
			}
			else
			{
				I.push_back(audio_data[i]);
			}
		}
	}


}
